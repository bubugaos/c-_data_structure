## 多步爬楼梯：

#### 题目描述1

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

#### 示例 1： 

```
输入： 2 

输出： 2 

解释： 有两种方法可以爬到楼顶。

1 阶 + 1 阶
2 阶
```



#### 示例 2：

```
输入： 3 

输出： 3 解释： 有三种方法可以爬到楼顶。

1 阶 + 1 阶 + 1 阶
1 阶 + 2 阶
2 阶 + 1 阶
```

1阶，2阶，.... m阶就是物品，楼顶就是背包。

每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。

问跳到楼顶有几种方法其实就是问装满背包有几种方法。

这是一道完全背包问题

### 分析：

```
1.确定dp数组含义：爬到i个台阶的楼顶有dp[i]种方法
2.确定递推公式：求背包问题有几种方法的递推公式一般都为dp[i] += dp[i-nums[i]];
本题的递推公式为：dp[i] += dp[i-j]
3.初始化dp数组：有递推公式可以看出dp[0] = 1因为dp[0]是递推过程中一切数值的基础，如果dp[0]为0，则其他数值都是0
4.确立遍历顺序：本题是排列问题，即外层遍历背包，内层遍历物品。假如是组合问题，则外层是遍历物品，内层是遍历背包
5.举例推导dp数组
```

### 代码

```c++
#include<iostream>
#include<vector>
using namespace std;
class Solution{
	public:
		int climbStairs(int n, int m) {
			vector<int> dp(n+1);
			dp[0] = 1;
			for (int i = 1; i <= n; i++) {//遍历背包
				for (int j = 1; j <= m; j++) {//遍历物品
					if (i-j >= 0) dp[i] += dp[i-j];
				}
			}
			return dp[n];
		}
};
int main() {
	int n, m;
	cin>>n>>m;
	Solution Q;
	cout<<Q.climbStairs(n,m);
}
```

